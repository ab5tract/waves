
Examples:
    
    action( :list, :get => [ :resources ] ) do
      action( :all ) and render( :list )
    end
    
    action( :read, :get => [ :resource, :name, { :mode => 'show' } ] ) do
      action( :find, name ) and render( mode )
    end
    
    action( :create, :post => [ :resources ] ) do
      redirect( paths.read( action( :create ).name, 'edit' ) )
    end
    
    action( :update, :put => [ :resource, :name ] ) do
      action( :update, name ) and redirect( paths.read( name ) )
    end
    
    action( :delete, :delete => [ :resource, :name ] ) do
      action( :delete, name )
    end

== Mappings

An action declaration
  is defined using Mapping#action
  evaluates in the scope of a Resource object
  uses app::Resources::Default when a resource has not been otherwise specified
  may specify a resource in the options with a key of :resource
  may specify a resource using pattern matching against the request path
  may be given a name, using a Symbol as its first argument
  calls the Resource method with the mapping's name when the mapping is triggered
  requires a block when the mapping is anonymous
  defines a method on the Resource when a block is given
  defines a path generator method on its resource's "shadow" Paths object
  
  # path pattern matching
  specifies the path to match using the HTTP method as the key and an Array as the value
    each item in the Array corresponds to a URL component
    strings match exact strings
    symbols are matched against a default Regexp
      these matches become named parameters
    regexps can be used, but their matches are not saved as named parameters. 
    a custom Regexp can be supplied as a hash
      action( :show, :get => [ :resources, { :name => /\w+/ } ] ) { path( resource, name ) }
    if the component hash value is a string, it is used as the default value when the url omits that component
      Obviously, this will only really work for optional arguments at the end of the path.
  
  # other constraints
  can match on the Accepts header (and others?) using additional hash pairs (:accepts => 'Nothing')
  can match against the host name using a key of :domain with a String value
  can match against the url scheme using a key of :scheme with a String value
  

  



An exception handler
  is defined using Mapping#handle
  uses the Error resource by default
  can take the same constraints as an action
  ( can it take a name?  would that be useful in any way? )
  

:before, :after, :always  filters
  take the same constraints as actions
  are defined using methods of the appropriate name
  apparently can be given names, which define methods on Resource and Paths???


Mapping#with(options, &block) 
  specifies options to be used for mappings done in a block

== Resources

A Resource object
  has a "shadow" Paths object
  can access its Paths object using Resource#paths or Resource.paths (see the #create mapping rule)


A Paths object 
  has path generating methods created by mappings
  has a class hierarchy mirroring its Resource's ancestry
  has heritable generator methods
  * path generators honor the optional arguments supplied as a Hash, using defaults if not supplied


The Default resource defines these methods

  #action calls your controller for you with the given method and arguments.
  #render does the same thing for your view. 
  #redirect takes a string (probably generated by the Paths object) for the location
  Parameters can be accessed as local methods using #method_missing.
  #view and #controller take blocks to run in the view or controller scope
    All the necessary parameter passing is handled for you (investigate)
  #resources and #resource have seamless bi-directional inflection.
  
  

== Misc

RFE:  We will also add regexp matching to constraints (like the domain) in the very near future.

In the dispatcher:

actions
  first match wins

handlers
  first match wins

filters
  all matches run
